// Group 15
// Alex Mathai - 2016A7PS0339P
// Sarthak Agarwal - 2016A7PS0135P
// Sanchit Shrivastava - 2016A7PS0072P
// Aman Sanghi - 2016A7PS0024P

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include "lexer.h"
#include "parser.h"
#include "ast.h"
#include "symboltable.h"
#include "codegen.h"


void printtoken(FILE* fp,Grammar* G)

{
	(*currIndex)=0;
	lineNo=1;
	checkbuffer=0;
	buffer0=(char*)malloc(Bufferlen*sizeof(char));
	buffer1=(char*)malloc(Bufferlen*sizeof(char));
	
	getStream(fp,buffer1);
	getStream(fp,buffer0);
	
	while(1)
	{
		checkbuffer=0;
		tokenInfo* gottoken=getNextToken(fp,G->searchtable);
		if(checkbuffer==1)
		{
			getStream(fp,buffer0);
		}
		if(gottoken->token_id==(G->terminals->size)-1)
		{
			return;
		}
		printf("Line %d: %s | %s  id %d \n",gottoken->lineNo,gottoken->lexeme_value,G->terminals->arr[gottoken->token_id],gottoken->token_id);
	}
	free(buffer1);
	free(buffer0);
}


int main(int argc, char* argv[])
{
	clock_t    start_time, end_time;
	double total_CPU_time, total_CPU_time_in_seconds;

	if(argc != 2 && argc != 3)
	{
		printf("Incorrect format\n");
		printf("Correct Format: %s <testcaseFile>\n", argv[0]);
		return 0;
	}

	FILE* fp=fopen(argv[1],"r");
	if(fp==NULL)
	{
		//printf("askdjskad\n");
		printf("Invalid testcaseFile\n");
		return 0;
	}
	fclose(fp);	
	
	// printf("FIRST and FOLLOW set automated\n");
	// printf("Both lexical and syntax analysis modules implemented\n");
	// printf("Modules work with all the given testcases\n");
	// printf("Parse tree could be constructed\n");

	printf("\nPress option for the defined task\n");
	printf("0 :  For exit.\n");
	printf("1 :  For printing the token list generated by the lexer.\n");
	printf("2 :  To verify the syntactic correctness of the code and print parse tree (On Console).\n");
	printf("3 :  For printing the Abstract Syntax Tree (On Console) .\n");
	printf("4 :  For displaying the amount of allocated memory and number of nodes (On Console) .\n");
	printf("5 :  For printing the Symbol Table (On Console) .\n");
	printf("6 :  For printing the list of global variables, their types and offsets (On Console) .\n");
	printf("7 :  For printing the total memory requirement (On Console) .\n");
	printf("8 :  For printing the type expressions and width of globally visible record definitions .\n");
	printf("9 :  To verify the syntactic and semantic correctness of the input source code .\n");
	printf("10 : For producing assembly code (in output.asm) .\n");

	int input;
	printf("\nEnter your choice: ");
	scanf(" %d", &input);

	//initializing grammar and global variables

	start_time = clock();
	//showcomment=0;
	//parser_pt* ptree = parseInputSourceCode(argv[1],T,G,F);
	//showcomment=1;
	Grammar *G = getgrammar("grammar.txt");
	//printf("asd\n");
	symbol_table=createHastable(13);
	//printf("asd\n");
	fill_symbol_table(G->searchtable);
	//printf("asd\n");
	FirstFollow *F=getfirstfollow(G);
	showerror=1;
	//printf("asd\n");
	currIndex=(int*)malloc(sizeof(int));	
	//printf("asd\n");
	showcomment=0;
	//printf("asd\n");
	table* T = createParseTable(F,G);
	int ptreenodes=0;
	int astnodes=0;
	int* ptreenodespointer=&ptreenodes;
	int* astnodespointer=&astnodes;

	//printf("asd\n");

	parser_pt* ptree = parseInputSourceCode(argv[1],T,G,F);
	//printf("asd\n");
	ASTM* alex=NULL;
	if(ptree!=NULL)
	{
		alex = post_ast_order(ptree);
	}

	func=generatehashtable(10);
	globalvar=generatehashtable(10);
	record=generatehashtable(10);
	variable=generatehashtable(10);
	
	if(alex!=NULL)
	{
				
		errorlisttable();
		fillsymboltable1(alex->root);
		fillsymboltable0(alex->root);
		fillsymboltable(alex->root);

		verifyallsymboltable(alex->root);
		/*
		printf("Function details\n");
		printfunc();
		printf("Main func variable\n");
		printvar(variable);
		printf("Global variable\n");
		printvar(globalvar);
		printf("Record information\n");
		printrecord();
		printnasmlist(mainvariable());
		
		printnasmlist(globalvar->head);
		printsymboltable();
		printarray();
		*/
	}

	end_time = clock();
	total_CPU_time  =  (double) (end_time - start_time);
	total_CPU_time_in_seconds =   total_CPU_time / CLOCKS_PER_SEC;
	

	//printRules(G);
	while(input!=0)
	{
		if(input==1)
		{
			FILE* fp=fopen(argv[1],"r");
			if(fp==NULL)
			{
				printf("Invalid testcaseFile\n");
				return 0;
			}
			showerror=0;
			printtoken(fp,G);
			showerror=1;
		}
		else if(input==2)
		{
			showcomment=0;
			if(ptree != NULL)
			{			
				printParseTree(ptree,G);
				printf("\nSource code file is syntactically correct \n");
			}
			else{
				printf("\nSource code file is syntactically Incorrect \n");
				printf("As syntax of the file is not correct, parse tree will not be created \n");
			}
			showcomment=1;
			
		}
		else if(input ==3)
		{
			if(alex==NULL)
			{
				printf("\nSource code file is syntactically Incorrect \n");
				printf("As syntax of the file is not correct, abstract syntax tree and parse tree will not be created \n");
			}
			else
			{
				printf("\nInorder Traversal:\n");
				printf("\nLabel	lexeme_value	parentlabel	firstchildlabel	siblinglabel\n");
				print_ast_tree(alex);
			}
		}
		else if(input==4)
		{
			if(ptree==NULL)
			{
				printf("As syntax of the file is not correct, parse tree will not be created\nHence cannot output compression percentage\n");
			}
			else
			{
				getptreenodes(ptree,G,ptreenodespointer);
				getastnodes(alex,astnodespointer);
				int sizeptree=ptreenodes*sizeof(struct parser_ptnode);
				int sizeast=astnodes*sizeof(struct astNode);
				printf("\nParse tree Number of nodes = %d	 Allocated Memory = %d Bytes\n",ptreenodes,sizeptree);
				printf("\nAST Number of nodes = %d			 Allocated Memory = %d Bytes\n",astnodes,sizeast);		
				float compression = (float)(((float)sizeptree-(float)sizeast)/(float)sizeptree)*100;
				printf("\nCompression percentage = ((%d‚Äê%d)/%d)*100 = %.2f\n",sizeptree,sizeast,sizeptree,compression);
				
			}
		}
		else if(input==5)
		{
			//print symbol tble on console
			if(alex!=NULL)
			{

				printsymboltable();
			}
			else
			{
				printf("\nAs syntax of the file is not correct, symbol table will not be created\n");
			}

		}
		else if(input==6)
		{
			//print list of global variables, their types and offsets
			if(alex!=NULL)
			{
				printglobalvar(globalvar);
			}
			else
			{
				printf("\nAs syntax of the file is not correct, symbol table will not be created\n");
			}
		}
		else if(input==7)
		{
			//print total memory requirement (sum total of widths of all variables in the function scope) for each function
			if(alex!=NULL)
			{
				functionsize();
			}
			else
			{
				printf("\nAs syntax of the file is not correct, symbol table will not be created\n");
			}
		}
		else if(input==8)
		{
			//print type expressions and width of globally visible record definitions;
			recordprint();

		}
		else if(input==9)
		{
			//time and error and correctness
			printarray();
			int i;
			int bits=0;
			for(i=0;i<200;i++)
			{
				if(errorlist[i]!=NULL)
					bits=1;
			}
			if(bits==0)
			{
				printf("No errors\n");

				printf("\ntotal_CPU_time = %f \ntotal_CPU_time_in_seconds = %f \n",total_CPU_time,total_CPU_time_in_seconds);

			}

		}
		else if(input==10)
		{
			//generate assembly code
			if(alex==NULL)
			{
				printf("\n\n");
			}
			else
			{
				FILE* fp=fopen("output.asm","w");
				if(fp == NULL){
					printf("Can't open file\n");
					break;
				}
				codegenerator(fp,alex);
				printf("\nnasm file output.asm created\n");
			}
		}
		else
		{
			printf("Incorrect input. Please enter number between 0 and 10\n");
			input=0;
		}		
		printf("\nEnter your choice: ");
		scanf("%d", &input);
	}
	
	freeGrammar(G);
	freeFirstFollow(F);
	
	return 0;
}
